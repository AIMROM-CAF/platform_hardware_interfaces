/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package android.hardware.radio@1.5;

import @1.1::EutranBands;
import @1.1::GeranBands;
import @1.1::RadioAccessNetworks;
import @1.1::RadioAccessSpecifier;
import @1.1::ScanType;
import @1.1::UtranBands;
import @1.2::CellIdentityCdma;
import @1.2::CellIdentityGsm;
import @1.2::CellIdentityWcdma;
import @1.2::CellIdentityTdscdma;
import @1.2::CellIdentityLte;
import @1.2::NetworkScanRequest;
import @1.4::AccessNetwork;
import @1.4::ApnTypes;
import @1.4::CellIdentityNr;
import @1.4::DataCallFailCause;
import @1.4::DataConnActiveStatus;
import @1.4::DataProfileInfo;
import @1.4::PdpProtocolType;

import android.hidl.safe_union@1.0::Monostate;

/**
 * Defining signal strength type.
 */
enum SignalMeasurementType : int32_t {
    /**
     * Received Signal Strength Indication.
     * Range: -113 dBm and -51 dBm
     * Used RAN: GERAN, CDMA2000
     * Reference: 3GPP TS 27.007 section 8.5.
     */
    RSSI = 1,
    /**
     * Received Signal Code Power.
     * Range: -120 dBm to -25 dBm;
     * Used RAN: UTRAN
     * Reference: 3GPP TS 25.123, section 9.1.1.1
     */
    RSCP = 2,
    /**
     * Reference Signal Received Power.
     * Range: -140 dBm to -44 dBm;
     * Used RAN: EUTRAN
     * Reference: 3GPP TS 36.133 9.1.4
     */
    RSRP = 3,
    /**
     * Reference Signal Received Quality
     * Range: -34 dB to 3 dB;
     * Used RAN: EUTRAN
     * Reference: 3GPP TS 36.133 v12.6.0 section 9.1.7
     */
    RSRQ = 4,
    /**
     * Reference Signal Signal to Noise Ratio
     * Range: -20 dB to 30 dB;
     * Used RAN: EUTRAN
     * Note: this field is optional; how to support it can be decided by the
     * corresponding vendor. Though the response code is not enforced,
     * vendor's implementation must ensure this interface not crashing.
     */
    RSSNR = 5,
    /**
     * 5G SS reference signal received power.
     * Range: -140 dBm to -44 dBm.
     * Used RAN: NGRAN
     * Reference: 3GPP TS 38.215.
     */
    SSRSRP = 6,
    /**
     * 5G SS reference signal received quality.
     * Range: -20 dB to -3 dB.
     * Used RAN: NGRAN
     * Reference: 3GPP TS 38.215.
     */
    SSRSRQ = 7,
    /**
     * 5G SS signal-to-noise and interference ratio.
     * Range: -23 dB to 40 dB
     * Used RAN: NGRAN
     * Reference: 3GPP TS 38.215 section 5.1.*, 3GPP TS 38.133 section 10.1.16.1.
     */
    SSSINR = 8,
};

/**
 * Contains the threshold values of each signal measurement type.
 */
struct SignalThresholdInfo {
    /** Signal Measurement Type */
    SignalMeasurementType signalMeasurement;

    /** A hysteresis time in milliseconds to prevent flapping. A value of 0 disables hysteresis */
    int32_t hysteresisMs;

    /**
     * An interval in dB defining the required magnitude change between reports.
     * hysteresisDb must be smaller than the smallest threshold delta.
     * An interval value of 0 disables hysteresis.
     */
    int32_t hysteresisDb;

    /**
     * List of threshold values.
     * Range and unit must reference specific @1.5::SignalMeasurementType.
     * The threshold values for which to apply criteria.
     * A vector size of 0 disables the use of thresholds for reporting.
     */
    vec<int32_t> thresholds;

    /**
     * Indicates whether the reporting criteria of the corresponding measurement is enabled
     * (isEnabled==true) or disabled (isEnabled==false).
     *
     * If enabled, modem must trigger the report based on the criteria.
     * If disabled, modem must not trigger the report based on the criteria.
     */
    bool isEnabled;
};

enum AccessNetwork : @1.4::AccessNetwork {
    /**
     *  Next-Generation Radio Access Network (NGRAN)
     */
    NGRAN = 6,
};

enum RadioAccessNetworks : @1.1::RadioAccessNetworks {
    NGRAN = 4,
};

/**
 * Overwritten from @1.1::RadioAccessSpecifier to add NGRAN and NgranBands
 */
struct RadioAccessSpecifier {
    /**
     * The type of network to scan.
     */
    RadioAccessNetworks radioAccessNetwork;

    /**
     * The frequency bands to scan.
     * Maximum length of the vector is 8.
     */
    safe_union Bands {
        /** Valid only if radioAccessNetwork = GERAN. */
        vec<GeranBands> geranBands;
        /** Valid only if radioAccessNetwork = UTRAN. */
        vec<UtranBands> utranBands;
        /** Valid only if radioAccessNetwork = EUTRAN. */
        vec<EutranBands> eutranBands;
        /** Valid only if radioAccessNetwork = NGRAN. */
        vec<NgranBands> ngranBands;
    } bands;

    /**
     * The radio channels to scan as defined in 3GPP TS 25.101 and 36.101.
     * Maximum length of the vector is 32.
     */
    vec<int32_t> channels;
};

enum NgranBands : int32_t {
    /** 3GPP TS 38.101-1, Table 5.2-1: FR1 bands */
    BAND_1 = 1,
    BAND_2 = 2,
    BAND_3 = 3,
    BAND_5 = 5,
    BAND_7 = 7,
    BAND_8 = 8,
    BAND_12 = 12,
    BAND_14 = 14,
    BAND_18 = 18,
    BAND_20 = 20,
    BAND_25 = 25,
    BAND_28 = 28,
    BAND_29 = 29,
    BAND_30 = 30,
    BAND_34 = 34,
    BAND_38 = 38,
    BAND_39 = 39,
    BAND_40 = 40,
    BAND_41 = 41,
    BAND_48 = 48,
    BAND_50 = 50,
    BAND_51 = 51,
    BAND_65 = 65,
    BAND_66 = 66,
    BAND_70 = 70,
    BAND_71 = 71,
    BAND_74 = 74,
    BAND_75 = 75,
    BAND_76 = 76,
    BAND_77 = 77,
    BAND_78 = 78,
    BAND_79 = 79,
    BAND_80 = 80,
    BAND_81 = 81,
    BAND_82 = 82,
    BAND_83 = 83,
    BAND_84 = 84,
    BAND_86 = 86,
    BAND_90 = 90,
    /** 3GPP TS 38.101-2, Table 5.2-1: FR2 bands */
    BAND_257 = 257,
    BAND_258 = 258,
    BAND_260 = 260,
    BAND_261 = 261,
};

/**
 * Overwritten from @1.2::NetworkScanRequest to update
 * RadioAccessSpecifier to 1.5 version
 */
struct NetworkScanRequest {
    ScanType type;

    /**
     * Time interval in seconds between the completion of one scan and the start of
     * a subsequent scan.
     * Implementations may ignore this field unless the 'type' is 'PERIODIC'.
     * Range: ScanIntervalRange:MIN to ScanIntervalRange:MAX
     */
    int32_t interval;

    /**
     * Networks with bands/channels to scan
     * Maximum length of the vector is RadioConst:RADIO_ACCESS_SPECIFIER_MAX_SIZE
     */
    vec<RadioAccessSpecifier> specifiers;

    /**
     * Maximum duration of the periodic search (in seconds).
     * If the search lasts maxSearchTime, it must be terminated.
     * Range: MaxSearchTimeRange:MIN to MaxSearchTimeRange:MAX
     */
    int32_t maxSearchTime;

    /**
     * Indicates whether the modem must report incremental results of the network scan
     * to the client.
     * FALSE – Incremental results must not be reported.
     * TRUE  – Incremental must be reported.
     */
    bool incrementalResults;

    /**
     * Indicates the periodicity with which the modem must report incremental results to
     * the client (in seconds).
     * Implementations may ignore this value if the incremental results are not requested.
     * This value must be less than or equal to maxSearchTime.
     * Range: IncrementalResultsPeriodicityRange:MIN to IncrementalResultsPeriodicityRange:MAX
     */
    int32_t incrementalResultsPeriodicity;

    /**
     * Describes the List of PLMN ids (MCC-MNC)
     * If any PLMN of this list is found, search must end at that point and results with all
     * PLMN found until that point should be sent as response.
     * If the list is not sent, search to be completed until end and all PLMNs found to be
     * reported.
     */
    vec<string> mccMncs;
};

enum ApnTypes : @1.4::ApnTypes {
    /**
     * APN type for XCAP
     * NOTE: Due to the addition of this new value, the value ALL defined in
     * 1.0::ApnTypes is deprecated and should not be used.
     */
    XCAP = 1 << 11,
};

/**
 * Extended from @1.4::DataProfileInfo to update ApnTypes to 1.5 version
 */
struct DataProfileInfo {
    @1.4::DataProfileInfo base;

    /** Supported APN types bitmap. See ApnTypes for the value of each bit. */
    bitfield<ApnTypes> supportedApnTypesBitmap;
};

/**
 * The properties of the link address. This enum reflects the definition in
 * if_addr.h in Linux kernel.
 */
enum AddressProperty : int32_t {
    NONE = 0,

    /** Indicates this address is deprecated */
    DEPRECATED = 0x20,
};

/**
 * Describes a data link address for mobile data connection.
 */
struct LinkAddress {
    /**
     * The format is IP address with optional "/"
     * prefix length (The format is defined in RFC-4291 section 2.3). For example, "192.0.1.3",
     * "192.0.1.11/16", or "2001:db8::1/64". Typically one IPv4 or one IPv6 or one of each. If
     * the prefix length is absent, then the addresses are assumed to be point to point with
     * IPv4 with prefix length 32 or IPv6 with prefix length 128.
     */
    string address;

    /**
     * The properties of the link address
     */
    bitfield<AddressProperty> properties;

    /**
     * The UTC time that this link address will be deprecated. 0 indicates this information is not
     * available.
     */
    uint64_t deprecatedTime;

    /**
     * The UTC time that this link address will expire and no longer valid. 0 indicates this
     * information is not available.
     */
    uint64_t expiredTime;
};

/**
 * Overwritten from @1.4::SetupDataCallResult in order to update the addresses to 1.5
 * version. In 1.5 the type of addresses changes to vector of LinkAddress.
 */
struct SetupDataCallResult {
    /** Data call fail cause. DataCallFailCause.NONE if no error. */
    DataCallFailCause cause;

    /**
     * If status != DataCallFailCause.NONE, this field indicates the suggested retry back-off timer
     * value RIL wants to override the one pre-configured in FW. The unit is milliseconds.
     * The value < 0 means no value is suggested.
     * The value 0 means retry must be done ASAP.
     * The value of INT_MAX(0x7fffffff) means no retry.
     */
    int32_t suggestedRetryTime;

    /** Context ID, uniquely identifies this call. */
    int32_t cid;

    /** Data connection active status. */
    DataConnActiveStatus active;

    /**
     * PDP_type values. If cause is DataCallFailCause.ONLY_SINGLE_BEARER_ALLOWED, this is the type
     * supported such as "IP" or "IPV6".
     */
    PdpProtocolType type;

    /** The network interface name. */
    string ifname;

    /**
     * List of link address.
     */
    vec<LinkAddress> addresses;

    /**
     * List of DNS server addresses, e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1". Empty if no dns
     * server addresses returned.
     */
    vec<string> dnses;

    /**
     * List of default gateway addresses, e.g., "192.0.1.3" or "192.0.1.11 2001:db8::1".
     * When empty, the addresses represent point to point connections.
     */
    vec<string> gateways;

    /**
     * List of P-CSCF(Proxy Call State Control Function) addresses via PCO(Protocol Configuration
     * Option), e.g., "2001:db8::1 2001:db8::2 2001:db8::3". Empty if not IMS client.
     */
    vec<string> pcscf;

    /**
     * MTU received from network. Value <= 0 means network has either not sent a value or sent an
     * invalid value.
     */
    int32_t mtu;
};

enum Domain : int32_t {
    /** Circuit-switched */
    CS = 1 << 0,

    /** Packet-switched */
    PS = 1 << 1,
};

/** A union representing the CellIdentity of a single cell */
safe_union CellIdentity {
    Monostate noinit;

    CellIdentityGsm gsm;
    CellIdentityWcdma wcdma;
    CellIdentityTdscdma tdscdma;
    CellIdentityCdma cdma;
    CellIdentityLte lte;
    CellIdentityNr nr;
};
